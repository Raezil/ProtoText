// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"sqlite","activeProvider":"sqlite","url":{"fromEnvVar":"","value":"file:dev.db"},"config":null}]`

const schema = `datasource db {
  provider = "sqlite" // or "postgresql", "mysql", etc.
  url      = "file:dev.db"
}

generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}

model User {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  name      String
  password  String
  email     String    @unique
  desc      String?
  post      Post[]
  comments  Comment[] // Opposite relation field added
}

model Post {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  content   String
  title     String

  author   User      @relation(fields: [authorID], references: [id])
  authorID String
  comments Comment[]
}

model Comment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  content   String

  post   Post   @relation(fields: [postID], references: [id])
  postID String
  user   User   @relation(fields: [userID], references: [id])
  userID String
}
`
const schemaDatasourceURL = "file:dev.db"
const schemaEnvVarName = ""

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set " + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}
	c.Post = postActions{client: c}
	c.Comment = commentActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
	// Post provides access to CRUD methods.
	Post postActions
	// Comment provides access to CRUD methods.
	Comment commentActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelSerializable TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID        UserScalarFieldEnum = "id"
	UserScalarFieldEnumCreatedAt UserScalarFieldEnum = "createdAt"
	UserScalarFieldEnumUpdatedAt UserScalarFieldEnum = "updatedAt"
	UserScalarFieldEnumName      UserScalarFieldEnum = "name"
	UserScalarFieldEnumPassword  UserScalarFieldEnum = "password"
	UserScalarFieldEnumEmail     UserScalarFieldEnum = "email"
	UserScalarFieldEnumDesc      UserScalarFieldEnum = "desc"
)

type PostScalarFieldEnum string

const (
	PostScalarFieldEnumID        PostScalarFieldEnum = "id"
	PostScalarFieldEnumCreatedAt PostScalarFieldEnum = "createdAt"
	PostScalarFieldEnumContent   PostScalarFieldEnum = "content"
	PostScalarFieldEnumTitle     PostScalarFieldEnum = "title"
	PostScalarFieldEnumAuthorID  PostScalarFieldEnum = "authorID"
)

type CommentScalarFieldEnum string

const (
	CommentScalarFieldEnumID        CommentScalarFieldEnum = "id"
	CommentScalarFieldEnumCreatedAt CommentScalarFieldEnum = "createdAt"
	CommentScalarFieldEnumContent   CommentScalarFieldEnum = "content"
	CommentScalarFieldEnumPostID    CommentScalarFieldEnum = "postID"
	CommentScalarFieldEnumUserID    CommentScalarFieldEnum = "userID"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type userPrismaFields = prismaFields

const userFieldID userPrismaFields = "id"

const userFieldCreatedAt userPrismaFields = "createdAt"

const userFieldUpdatedAt userPrismaFields = "updatedAt"

const userFieldName userPrismaFields = "name"

const userFieldPassword userPrismaFields = "password"

const userFieldEmail userPrismaFields = "email"

const userFieldDesc userPrismaFields = "desc"

const userFieldPost userPrismaFields = "post"

const userFieldComments userPrismaFields = "comments"

type postPrismaFields = prismaFields

const postFieldID postPrismaFields = "id"

const postFieldCreatedAt postPrismaFields = "createdAt"

const postFieldContent postPrismaFields = "content"

const postFieldTitle postPrismaFields = "title"

const postFieldAuthor postPrismaFields = "author"

const postFieldAuthorID postPrismaFields = "authorID"

const postFieldComments postPrismaFields = "comments"

type commentPrismaFields = prismaFields

const commentFieldID commentPrismaFields = "id"

const commentFieldCreatedAt commentPrismaFields = "createdAt"

const commentFieldContent commentPrismaFields = "content"

const commentFieldPost commentPrismaFields = "post"

const commentFieldPostID commentPrismaFields = "postID"

const commentFieldUser commentPrismaFields = "user"

const commentFieldUserID commentPrismaFields = "userID"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	m.Post = postMock{
		mock: m,
	}

	m.Comment = commentMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock

	Post postMock

	Comment commentMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type postMock struct {
	mock *Mock
}

type PostMockExpectParam interface {
	ExtractQuery() builder.Query
	postModel()
}

func (m *postMock) Expect(query PostMockExpectParam) *postMockExec {
	return &postMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type postMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *postMockExec) Returns(v PostModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *postMockExec) ReturnsMany(v []PostModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *postMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type commentMock struct {
	mock *Mock
}

type CommentMockExpectParam interface {
	ExtractQuery() builder.Query
	commentModel()
}

func (m *commentMock) Expect(query CommentMockExpectParam) *commentMockExec {
	return &commentMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type commentMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *commentMockExec) Returns(v CommentModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *commentMockExec) ReturnsMany(v []CommentModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *commentMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
	Name      string   `json:"name"`
	Password  string   `json:"password"`
	Email     string   `json:"email"`
	Desc      *string  `json:"desc,omitempty"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	ID        RawString   `json:"id"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
	Name      RawString   `json:"name"`
	Password  RawString   `json:"password"`
	Email     RawString   `json:"email"`
	Desc      *RawString  `json:"desc,omitempty"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
	Post     []PostModel    `json:"post,omitempty"`
	Comments []CommentModel `json:"comments,omitempty"`
}

func (r UserModel) Desc() (value String, ok bool) {
	if r.InnerUser.Desc == nil {
		return value, false
	}
	return *r.InnerUser.Desc, true
}

func (r UserModel) Post() (value []PostModel) {
	if r.RelationsUser.Post == nil {
		panic("attempted to access post but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Post
}

func (r UserModel) Comments() (value []CommentModel) {
	if r.RelationsUser.Comments == nil {
		panic("attempted to access comments but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Comments
}

// PostModel represents the Post model and is a wrapper for accessing fields and methods
type PostModel struct {
	InnerPost
	RelationsPost
}

// InnerPost holds the actual data
type InnerPost struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	Content   string   `json:"content"`
	Title     string   `json:"title"`
	AuthorID  string   `json:"authorID"`
}

// RawPostModel is a struct for Post when used in raw queries
type RawPostModel struct {
	ID        RawString   `json:"id"`
	CreatedAt RawDateTime `json:"createdAt"`
	Content   RawString   `json:"content"`
	Title     RawString   `json:"title"`
	AuthorID  RawString   `json:"authorID"`
}

// RelationsPost holds the relation data separately
type RelationsPost struct {
	Author   *UserModel     `json:"author,omitempty"`
	Comments []CommentModel `json:"comments,omitempty"`
}

func (r PostModel) Author() (value *UserModel) {
	if r.RelationsPost.Author == nil {
		panic("attempted to access author but did not fetch it using the .With() syntax")
	}
	return r.RelationsPost.Author
}

func (r PostModel) Comments() (value []CommentModel) {
	if r.RelationsPost.Comments == nil {
		panic("attempted to access comments but did not fetch it using the .With() syntax")
	}
	return r.RelationsPost.Comments
}

// CommentModel represents the Comment model and is a wrapper for accessing fields and methods
type CommentModel struct {
	InnerComment
	RelationsComment
}

// InnerComment holds the actual data
type InnerComment struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	Content   string   `json:"content"`
	PostID    string   `json:"postID"`
	UserID    string   `json:"userID"`
}

// RawCommentModel is a struct for Comment when used in raw queries
type RawCommentModel struct {
	ID        RawString   `json:"id"`
	CreatedAt RawDateTime `json:"createdAt"`
	Content   RawString   `json:"content"`
	PostID    RawString   `json:"postID"`
	UserID    RawString   `json:"userID"`
}

// RelationsComment holds the relation data separately
type RelationsComment struct {
	Post *PostModel `json:"post,omitempty"`
	User *UserModel `json:"user,omitempty"`
}

func (r CommentModel) Post() (value *PostModel) {
	if r.RelationsComment.Post == nil {
		panic("attempted to access post but did not fetch it using the .With() syntax")
	}
	return r.RelationsComment.Post
}

func (r CommentModel) User() (value *UserModel) {
	if r.RelationsComment.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsComment.User
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userQueryUpdatedAtDateTime

	// Name
	//
	// @required
	Name userQueryNameString

	// Password
	//
	// @required
	Password userQueryPasswordString

	// Email
	//
	// @required
	// @unique
	Email userQueryEmailString

	// Desc
	//
	// @optional
	Desc userQueryDescString

	Post userQueryPostRelations

	Comments userQueryCommentsRelations
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIDString) Equals(value string) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EqualsIfPresent(value *string) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryIDString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryIDString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryIDString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryIDString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryIDString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryIDString) Field() userPrismaFields {
	return userFieldID
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userWithPrismaCreatedAtEqualsParam {

	return userWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCreatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCreatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCreatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCreatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCreatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCreatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCreatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryCreatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryCreatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryCreatedAtDateTime) Field() userPrismaFields {
	return userFieldCreatedAt
}

// base struct
type userQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userQueryUpdatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUpdatedAtDateTime) Equals(value DateTime) userWithPrismaUpdatedAtEqualsParam {

	return userWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUpdatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r userQueryUpdatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r userQueryUpdatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUpdatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUpdatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUpdatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUpdatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUpdatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUpdatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryUpdatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryUpdatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryUpdatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryUpdatedAtDateTime) Field() userPrismaFields {
	return userFieldUpdatedAt
}

// base struct
type userQueryNameString struct{}

// Set the required value of Name
func (r userQueryNameString) Set(value string) userWithPrismaNameSetParam {

	return userWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r userQueryNameString) SetIfPresent(value *String) userWithPrismaNameSetParam {
	if value == nil {
		return userWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryNameString) Equals(value string) userWithPrismaNameEqualsParam {

	return userWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) EqualsIfPresent(value *string) userWithPrismaNameEqualsParam {
	if value == nil {
		return userWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r userQueryNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r userQueryNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryNameString) Field() userPrismaFields {
	return userFieldName
}

// base struct
type userQueryPasswordString struct{}

// Set the required value of Password
func (r userQueryPasswordString) Set(value string) userWithPrismaPasswordSetParam {

	return userWithPrismaPasswordSetParam{
		data: builder.Field{
			Name:  "password",
			Value: value,
		},
	}

}

// Set the optional value of Password dynamically
func (r userQueryPasswordString) SetIfPresent(value *String) userWithPrismaPasswordSetParam {
	if value == nil {
		return userWithPrismaPasswordSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryPasswordString) Equals(value string) userWithPrismaPasswordEqualsParam {

	return userWithPrismaPasswordEqualsParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EqualsIfPresent(value *string) userWithPrismaPasswordEqualsParam {
	if value == nil {
		return userWithPrismaPasswordEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryPasswordString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "password",
			Value: direction,
		},
	}
}

func (r userQueryPasswordString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "password",
			Value: cursor,
		},
	}
}

func (r userQueryPasswordString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryPasswordString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryPasswordString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryPasswordString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryPasswordString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryPasswordString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryPasswordString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryPasswordString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryPasswordString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryPasswordString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryPasswordString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryPasswordString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryPasswordString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryPasswordString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryPasswordString) Field() userPrismaFields {
	return userFieldPassword
}

// base struct
type userQueryEmailString struct{}

// Set the required value of Email
func (r userQueryEmailString) Set(value string) userWithPrismaEmailSetParam {

	return userWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r userQueryEmailString) SetIfPresent(value *String) userWithPrismaEmailSetParam {
	if value == nil {
		return userWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryEmailString) Equals(value string) userWithPrismaEmailEqualsUniqueParam {

	return userWithPrismaEmailEqualsUniqueParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EqualsIfPresent(value *string) userWithPrismaEmailEqualsUniqueParam {
	if value == nil {
		return userWithPrismaEmailEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryEmailString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userQueryEmailString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userQueryEmailString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryEmailString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryEmailString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryEmailString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryEmailString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryEmailString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryEmailString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryEmailString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryEmailString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryEmailString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryEmailString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryEmailString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryEmailString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryEmailString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryEmailString) Field() userPrismaFields {
	return userFieldEmail
}

// base struct
type userQueryDescString struct{}

// Set the optional value of Desc
func (r userQueryDescString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "desc",
			Value: value,
		},
	}

}

// Set the optional value of Desc dynamically
func (r userQueryDescString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Desc dynamically
func (r userQueryDescString) SetOptional(value *String) userSetParam {
	if value == nil {

		var v *string
		return userSetParam{
			data: builder.Field{
				Name:  "desc",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r userQueryDescString) Equals(value string) userWithPrismaDescEqualsParam {

	return userWithPrismaDescEqualsParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) EqualsIfPresent(value *string) userWithPrismaDescEqualsParam {
	if value == nil {
		return userWithPrismaDescEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryDescString) EqualsOptional(value *String) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) IsNull() userDefaultParam {
	var str *string = nil
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r userQueryDescString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "desc",
			Value: direction,
		},
	}
}

func (r userQueryDescString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "desc",
			Value: cursor,
		},
	}
}

func (r userQueryDescString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryDescString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryDescString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryDescString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryDescString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryDescString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryDescString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryDescString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryDescString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryDescString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDescString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryDescString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryDescString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryDescString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "desc",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryDescString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryDescString) Field() userPrismaFields {
	return userFieldDesc
}

// base struct
type userQueryPostPost struct{}

type userQueryPostRelations struct{}

// User -> Post
//
// @relation
// @required
func (userQueryPostRelations) Some(
	params ...PostWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Post
//
// @relation
// @required
func (userQueryPostRelations) Every(
	params ...PostWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Post
//
// @relation
// @required
func (userQueryPostRelations) None(
	params ...PostWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryPostRelations) Fetch(

	params ...PostWhereParam,

) userToPostFindMany {
	var v userToPostFindMany

	v.query.Operation = "query"
	v.query.Method = "post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryPostRelations) Link(
	params ...PostWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryPostRelations) Unlink(
	params ...PostWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryPostPost) Field() userPrismaFields {
	return userFieldPost
}

// base struct
type userQueryCommentsComment struct{}

type userQueryCommentsRelations struct{}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) Some(
	params ...CommentWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) Every(
	params ...CommentWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) None(
	params ...CommentWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryCommentsRelations) Fetch(

	params ...CommentWhereParam,

) userToCommentsFindMany {
	var v userToCommentsFindMany

	v.query.Operation = "query"
	v.query.Method = "comments"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryCommentsRelations) Link(
	params ...CommentWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryCommentsRelations) Unlink(
	params ...CommentWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryCommentsComment) Field() userPrismaFields {
	return userFieldComments
}

// Post acts as a namespaces to access query methods for the Post model
var Post = postQuery{}

// postQuery exposes query functions for the post model
type postQuery struct {

	// ID
	//
	// @required
	ID postQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt postQueryCreatedAtDateTime

	// Content
	//
	// @required
	Content postQueryContentString

	// Title
	//
	// @required
	Title postQueryTitleString

	Author postQueryAuthorRelations

	// AuthorID
	//
	// @required
	AuthorID postQueryAuthorIDString

	Comments postQueryCommentsRelations
}

func (postQuery) Not(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (postQuery) Or(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (postQuery) And(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type postQueryIDString struct{}

// Set the required value of ID
func (r postQueryIDString) Set(value string) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r postQueryIDString) SetIfPresent(value *String) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryIDString) Equals(value string) postWithPrismaIDEqualsUniqueParam {

	return postWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) EqualsIfPresent(value *string) postWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return postWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r postQueryIDString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r postQueryIDString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r postQueryIDString) In(value []string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) InIfPresent(value []string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.In(value)
}

func (r postQueryIDString) NotIn(value []string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) NotInIfPresent(value []string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.NotIn(value)
}

func (r postQueryIDString) Lt(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) LtIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Lt(*value)
}

func (r postQueryIDString) Lte(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) LteIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Lte(*value)
}

func (r postQueryIDString) Gt(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) GtIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Gt(*value)
}

func (r postQueryIDString) Gte(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) GteIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Gte(*value)
}

func (r postQueryIDString) Contains(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) ContainsIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Contains(*value)
}

func (r postQueryIDString) StartsWith(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) StartsWithIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r postQueryIDString) EndsWith(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) EndsWithIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r postQueryIDString) Not(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) NotIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryIDString) HasPrefix(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryIDString) HasPrefixIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryIDString) HasSuffix(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryIDString) HasSuffixIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryIDString) Field() postPrismaFields {
	return postFieldID
}

// base struct
type postQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r postQueryCreatedAtDateTime) Set(value DateTime) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r postQueryCreatedAtDateTime) SetIfPresent(value *DateTime) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryCreatedAtDateTime) Equals(value DateTime) postWithPrismaCreatedAtEqualsParam {

	return postWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) postWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return postWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryCreatedAtDateTime) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r postQueryCreatedAtDateTime) Cursor(cursor DateTime) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r postQueryCreatedAtDateTime) In(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) InIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryCreatedAtDateTime) NotIn(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryCreatedAtDateTime) Lt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) LtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryCreatedAtDateTime) Lte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) LteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryCreatedAtDateTime) Gt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) GtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryCreatedAtDateTime) Gte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) GteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryCreatedAtDateTime) Not(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) NotIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQueryCreatedAtDateTime) Before(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r postQueryCreatedAtDateTime) After(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r postQueryCreatedAtDateTime) BeforeEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r postQueryCreatedAtDateTime) AfterEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r postQueryCreatedAtDateTime) Field() postPrismaFields {
	return postFieldCreatedAt
}

// base struct
type postQueryContentString struct{}

// Set the required value of Content
func (r postQueryContentString) Set(value string) postWithPrismaContentSetParam {

	return postWithPrismaContentSetParam{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}

}

// Set the optional value of Content dynamically
func (r postQueryContentString) SetIfPresent(value *String) postWithPrismaContentSetParam {
	if value == nil {
		return postWithPrismaContentSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryContentString) Equals(value string) postWithPrismaContentEqualsParam {

	return postWithPrismaContentEqualsParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) EqualsIfPresent(value *string) postWithPrismaContentEqualsParam {
	if value == nil {
		return postWithPrismaContentEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryContentString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "content",
			Value: direction,
		},
	}
}

func (r postQueryContentString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "content",
			Value: cursor,
		},
	}
}

func (r postQueryContentString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryContentString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryContentString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryContentString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryContentString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryContentString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryContentString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryContentString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryContentString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryContentString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryContentString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryContentString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryContentString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryContentString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryContentString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryContentString) Field() postPrismaFields {
	return postFieldContent
}

// base struct
type postQueryTitleString struct{}

// Set the required value of Title
func (r postQueryTitleString) Set(value string) postWithPrismaTitleSetParam {

	return postWithPrismaTitleSetParam{
		data: builder.Field{
			Name:  "title",
			Value: value,
		},
	}

}

// Set the optional value of Title dynamically
func (r postQueryTitleString) SetIfPresent(value *String) postWithPrismaTitleSetParam {
	if value == nil {
		return postWithPrismaTitleSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryTitleString) Equals(value string) postWithPrismaTitleEqualsParam {

	return postWithPrismaTitleEqualsParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) EqualsIfPresent(value *string) postWithPrismaTitleEqualsParam {
	if value == nil {
		return postWithPrismaTitleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryTitleString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "title",
			Value: direction,
		},
	}
}

func (r postQueryTitleString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "title",
			Value: cursor,
		},
	}
}

func (r postQueryTitleString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryTitleString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryTitleString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryTitleString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryTitleString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryTitleString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryTitleString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryTitleString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryTitleString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryTitleString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryTitleString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryTitleString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryTitleString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryTitleString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryTitleString) Field() postPrismaFields {
	return postFieldTitle
}

// base struct
type postQueryAuthorUser struct{}

type postQueryAuthorRelations struct{}

// Post -> Author
//
// @relation
// @required
func (postQueryAuthorRelations) Where(
	params ...UserWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryAuthorRelations) Fetch() postToAuthorFindUnique {
	var v postToAuthorFindUnique

	v.query.Operation = "query"
	v.query.Method = "author"
	v.query.Outputs = userOutput

	return v
}

func (r postQueryAuthorRelations) Link(
	params UserWhereParam,
) postWithPrismaAuthorSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return postWithPrismaAuthorSetParam{}
	}

	fields = append(fields, f)

	return postWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r postQueryAuthorRelations) Unlink() postWithPrismaAuthorSetParam {
	var v postWithPrismaAuthorSetParam

	v = postWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r postQueryAuthorUser) Field() postPrismaFields {
	return postFieldAuthor
}

// base struct
type postQueryAuthorIDString struct{}

// Set the required value of AuthorID
func (r postQueryAuthorIDString) Set(value string) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "authorID",
			Value: value,
		},
	}

}

// Set the optional value of AuthorID dynamically
func (r postQueryAuthorIDString) SetIfPresent(value *String) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryAuthorIDString) Equals(value string) postWithPrismaAuthorIDEqualsParam {

	return postWithPrismaAuthorIDEqualsParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) EqualsIfPresent(value *string) postWithPrismaAuthorIDEqualsParam {
	if value == nil {
		return postWithPrismaAuthorIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryAuthorIDString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "authorID",
			Value: direction,
		},
	}
}

func (r postQueryAuthorIDString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "authorID",
			Value: cursor,
		},
	}
}

func (r postQueryAuthorIDString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryAuthorIDString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryAuthorIDString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryAuthorIDString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryAuthorIDString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryAuthorIDString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryAuthorIDString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryAuthorIDString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryAuthorIDString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryAuthorIDString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryAuthorIDString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryAuthorIDString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryAuthorIDString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryAuthorIDString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryAuthorIDString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryAuthorIDString) Field() postPrismaFields {
	return postFieldAuthorID
}

// base struct
type postQueryCommentsComment struct{}

type postQueryCommentsRelations struct{}

// Post -> Comments
//
// @relation
// @required
func (postQueryCommentsRelations) Some(
	params ...CommentWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Comments
//
// @relation
// @required
func (postQueryCommentsRelations) Every(
	params ...CommentWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Comments
//
// @relation
// @required
func (postQueryCommentsRelations) None(
	params ...CommentWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryCommentsRelations) Fetch(

	params ...CommentWhereParam,

) postToCommentsFindMany {
	var v postToCommentsFindMany

	v.query.Operation = "query"
	v.query.Method = "comments"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postQueryCommentsRelations) Link(
	params ...CommentWhereParam,
) postSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r postQueryCommentsRelations) Unlink(
	params ...CommentWhereParam,
) postSetParam {
	var v postSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = postSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r postQueryCommentsComment) Field() postPrismaFields {
	return postFieldComments
}

// Comment acts as a namespaces to access query methods for the Comment model
var Comment = commentQuery{}

// commentQuery exposes query functions for the comment model
type commentQuery struct {

	// ID
	//
	// @required
	ID commentQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt commentQueryCreatedAtDateTime

	// Content
	//
	// @required
	Content commentQueryContentString

	Post commentQueryPostRelations

	// PostID
	//
	// @required
	PostID commentQueryPostIDString

	User commentQueryUserRelations

	// UserID
	//
	// @required
	UserID commentQueryUserIDString
}

func (commentQuery) Not(params ...CommentWhereParam) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (commentQuery) Or(params ...CommentWhereParam) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (commentQuery) And(params ...CommentWhereParam) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type commentQueryIDString struct{}

// Set the required value of ID
func (r commentQueryIDString) Set(value string) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r commentQueryIDString) SetIfPresent(value *String) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryIDString) Equals(value string) commentWithPrismaIDEqualsUniqueParam {

	return commentWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) EqualsIfPresent(value *string) commentWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return commentWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryIDString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r commentQueryIDString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r commentQueryIDString) In(value []string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) InIfPresent(value []string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.In(value)
}

func (r commentQueryIDString) NotIn(value []string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) NotInIfPresent(value []string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.NotIn(value)
}

func (r commentQueryIDString) Lt(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) LtIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Lt(*value)
}

func (r commentQueryIDString) Lte(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) LteIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Lte(*value)
}

func (r commentQueryIDString) Gt(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) GtIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Gt(*value)
}

func (r commentQueryIDString) Gte(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) GteIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Gte(*value)
}

func (r commentQueryIDString) Contains(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) ContainsIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Contains(*value)
}

func (r commentQueryIDString) StartsWith(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) StartsWithIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryIDString) EndsWith(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) EndsWithIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryIDString) Not(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) NotIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryIDString) HasPrefix(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryIDString) HasPrefixIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryIDString) HasSuffix(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryIDString) HasSuffixIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryIDString) Field() commentPrismaFields {
	return commentFieldID
}

// base struct
type commentQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r commentQueryCreatedAtDateTime) Set(value DateTime) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r commentQueryCreatedAtDateTime) SetIfPresent(value *DateTime) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryCreatedAtDateTime) Equals(value DateTime) commentWithPrismaCreatedAtEqualsParam {

	return commentWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) commentWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return commentWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryCreatedAtDateTime) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r commentQueryCreatedAtDateTime) Cursor(cursor DateTime) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r commentQueryCreatedAtDateTime) In(value []DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) InIfPresent(value []DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryCreatedAtDateTime) NotIn(value []DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryCreatedAtDateTime) Lt(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) LtIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryCreatedAtDateTime) Lte(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) LteIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryCreatedAtDateTime) Gt(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) GtIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryCreatedAtDateTime) Gte(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) GteIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryCreatedAtDateTime) Not(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) NotIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r commentQueryCreatedAtDateTime) Before(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r commentQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r commentQueryCreatedAtDateTime) After(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r commentQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r commentQueryCreatedAtDateTime) BeforeEquals(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r commentQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r commentQueryCreatedAtDateTime) AfterEquals(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r commentQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r commentQueryCreatedAtDateTime) Field() commentPrismaFields {
	return commentFieldCreatedAt
}

// base struct
type commentQueryContentString struct{}

// Set the required value of Content
func (r commentQueryContentString) Set(value string) commentWithPrismaContentSetParam {

	return commentWithPrismaContentSetParam{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}

}

// Set the optional value of Content dynamically
func (r commentQueryContentString) SetIfPresent(value *String) commentWithPrismaContentSetParam {
	if value == nil {
		return commentWithPrismaContentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryContentString) Equals(value string) commentWithPrismaContentEqualsParam {

	return commentWithPrismaContentEqualsParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) EqualsIfPresent(value *string) commentWithPrismaContentEqualsParam {
	if value == nil {
		return commentWithPrismaContentEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryContentString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "content",
			Value: direction,
		},
	}
}

func (r commentQueryContentString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "content",
			Value: cursor,
		},
	}
}

func (r commentQueryContentString) In(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) InIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryContentString) NotIn(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) NotInIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryContentString) Lt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) LtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryContentString) Lte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) LteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryContentString) Gt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) GtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryContentString) Gte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) GteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryContentString) Contains(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) ContainsIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentQueryContentString) StartsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) StartsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryContentString) EndsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) EndsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryContentString) Not(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) NotIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryContentString) HasPrefix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryContentString) HasPrefixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryContentString) HasSuffix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryContentString) HasSuffixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryContentString) Field() commentPrismaFields {
	return commentFieldContent
}

// base struct
type commentQueryPostPost struct{}

type commentQueryPostRelations struct{}

// Comment -> Post
//
// @relation
// @required
func (commentQueryPostRelations) Where(
	params ...PostWhereParam,
) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (commentQueryPostRelations) Fetch() commentToPostFindUnique {
	var v commentToPostFindUnique

	v.query.Operation = "query"
	v.query.Method = "post"
	v.query.Outputs = postOutput

	return v
}

func (r commentQueryPostRelations) Link(
	params PostWhereParam,
) commentWithPrismaPostSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return commentWithPrismaPostSetParam{}
	}

	fields = append(fields, f)

	return commentWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r commentQueryPostRelations) Unlink() commentWithPrismaPostSetParam {
	var v commentWithPrismaPostSetParam

	v = commentWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r commentQueryPostPost) Field() commentPrismaFields {
	return commentFieldPost
}

// base struct
type commentQueryPostIDString struct{}

// Set the required value of PostID
func (r commentQueryPostIDString) Set(value string) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "postID",
			Value: value,
		},
	}

}

// Set the optional value of PostID dynamically
func (r commentQueryPostIDString) SetIfPresent(value *String) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryPostIDString) Equals(value string) commentWithPrismaPostIDEqualsParam {

	return commentWithPrismaPostIDEqualsParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) EqualsIfPresent(value *string) commentWithPrismaPostIDEqualsParam {
	if value == nil {
		return commentWithPrismaPostIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryPostIDString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "postID",
			Value: direction,
		},
	}
}

func (r commentQueryPostIDString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "postID",
			Value: cursor,
		},
	}
}

func (r commentQueryPostIDString) In(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) InIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryPostIDString) NotIn(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) NotInIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryPostIDString) Lt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) LtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryPostIDString) Lte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) LteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryPostIDString) Gt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) GtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryPostIDString) Gte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) GteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryPostIDString) Contains(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) ContainsIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentQueryPostIDString) StartsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) StartsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryPostIDString) EndsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) EndsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryPostIDString) Not(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) NotIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryPostIDString) HasPrefix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryPostIDString) HasPrefixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryPostIDString) HasSuffix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postID",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryPostIDString) HasSuffixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryPostIDString) Field() commentPrismaFields {
	return commentFieldPostID
}

// base struct
type commentQueryUserUser struct{}

type commentQueryUserRelations struct{}

// Comment -> User
//
// @relation
// @required
func (commentQueryUserRelations) Where(
	params ...UserWhereParam,
) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (commentQueryUserRelations) Fetch() commentToUserFindUnique {
	var v commentToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r commentQueryUserRelations) Link(
	params UserWhereParam,
) commentWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return commentWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return commentWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r commentQueryUserRelations) Unlink() commentWithPrismaUserSetParam {
	var v commentWithPrismaUserSetParam

	v = commentWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r commentQueryUserUser) Field() commentPrismaFields {
	return commentFieldUser
}

// base struct
type commentQueryUserIDString struct{}

// Set the required value of UserID
func (r commentQueryUserIDString) Set(value string) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "userID",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r commentQueryUserIDString) SetIfPresent(value *String) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryUserIDString) Equals(value string) commentWithPrismaUserIDEqualsParam {

	return commentWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) EqualsIfPresent(value *string) commentWithPrismaUserIDEqualsParam {
	if value == nil {
		return commentWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryUserIDString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "userID",
			Value: direction,
		},
	}
}

func (r commentQueryUserIDString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "userID",
			Value: cursor,
		},
	}
}

func (r commentQueryUserIDString) In(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) InIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryUserIDString) NotIn(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) NotInIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryUserIDString) Lt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) LtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryUserIDString) Lte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) LteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryUserIDString) Gt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) GtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryUserIDString) Gte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) GteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryUserIDString) Contains(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) ContainsIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentQueryUserIDString) StartsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) StartsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryUserIDString) EndsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) EndsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryUserIDString) Not(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) NotIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryUserIDString) HasPrefix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryUserIDString) HasPrefixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryUserIDString) HasSuffix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryUserIDString) HasSuffixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryUserIDString) Field() commentPrismaFields {
	return commentFieldUserID
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "name"},
	{Name: "password"},
	{Name: "email"},
	{Name: "desc"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	createdAtField()
}

type UserWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtSetParam) userModel() {}

func (p userWithPrismaCreatedAtSetParam) createdAtField() {}

type UserWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsParam) userModel() {}

func (p userWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userWithPrismaCreatedAtSetParam) settable()  {}
func (userWithPrismaCreatedAtEqualsParam) equals() {}

type userWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	updatedAtField()
}

type UserWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtSetParam) userModel() {}

func (p userWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsParam) userModel() {}

func (p userWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userWithPrismaUpdatedAtSetParam) settable()  {}
func (userWithPrismaUpdatedAtEqualsParam) equals() {}

type userWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	nameField()
}

type UserWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	nameField()
}

type userWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNameSetParam) userModel() {}

func (p userWithPrismaNameSetParam) nameField() {}

type UserWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	nameField()
}

type userWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNameEqualsParam) userModel() {}

func (p userWithPrismaNameEqualsParam) nameField() {}

func (userWithPrismaNameSetParam) settable()  {}
func (userWithPrismaNameEqualsParam) equals() {}

type userWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNameEqualsUniqueParam) userModel() {}
func (p userWithPrismaNameEqualsUniqueParam) nameField() {}

func (userWithPrismaNameEqualsUniqueParam) unique() {}
func (userWithPrismaNameEqualsUniqueParam) equals() {}

type UserWithPrismaPasswordEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	passwordField()
}

type UserWithPrismaPasswordSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordSetParam) userModel() {}

func (p userWithPrismaPasswordSetParam) passwordField() {}

type UserWithPrismaPasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsParam) userModel() {}

func (p userWithPrismaPasswordEqualsParam) passwordField() {}

func (userWithPrismaPasswordSetParam) settable()  {}
func (userWithPrismaPasswordEqualsParam) equals() {}

type userWithPrismaPasswordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsUniqueParam) userModel()     {}
func (p userWithPrismaPasswordEqualsUniqueParam) passwordField() {}

func (userWithPrismaPasswordEqualsUniqueParam) unique() {}
func (userWithPrismaPasswordEqualsUniqueParam) equals() {}

type UserWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	emailField()
}

type UserWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailSetParam) userModel() {}

func (p userWithPrismaEmailSetParam) emailField() {}

type UserWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsParam) userModel() {}

func (p userWithPrismaEmailEqualsParam) emailField() {}

func (userWithPrismaEmailSetParam) settable()  {}
func (userWithPrismaEmailEqualsParam) equals() {}

type userWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsUniqueParam) userModel()  {}
func (p userWithPrismaEmailEqualsUniqueParam) emailField() {}

func (userWithPrismaEmailEqualsUniqueParam) unique() {}
func (userWithPrismaEmailEqualsUniqueParam) equals() {}

type UserWithPrismaDescEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	descField()
}

type UserWithPrismaDescSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	descField()
}

type userWithPrismaDescSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDescSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDescSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDescSetParam) userModel() {}

func (p userWithPrismaDescSetParam) descField() {}

type UserWithPrismaDescWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	descField()
}

type userWithPrismaDescEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDescEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDescEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDescEqualsParam) userModel() {}

func (p userWithPrismaDescEqualsParam) descField() {}

func (userWithPrismaDescSetParam) settable()  {}
func (userWithPrismaDescEqualsParam) equals() {}

type userWithPrismaDescEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDescEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDescEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDescEqualsUniqueParam) userModel() {}
func (p userWithPrismaDescEqualsUniqueParam) descField() {}

func (userWithPrismaDescEqualsUniqueParam) unique() {}
func (userWithPrismaDescEqualsUniqueParam) equals() {}

type UserWithPrismaPostEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	postField()
}

type UserWithPrismaPostSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	postField()
}

type userWithPrismaPostSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPostSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPostSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPostSetParam) userModel() {}

func (p userWithPrismaPostSetParam) postField() {}

type UserWithPrismaPostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	postField()
}

type userWithPrismaPostEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPostEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPostEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPostEqualsParam) userModel() {}

func (p userWithPrismaPostEqualsParam) postField() {}

func (userWithPrismaPostSetParam) settable()  {}
func (userWithPrismaPostEqualsParam) equals() {}

type userWithPrismaPostEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPostEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPostEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPostEqualsUniqueParam) userModel() {}
func (p userWithPrismaPostEqualsUniqueParam) postField() {}

func (userWithPrismaPostEqualsUniqueParam) unique() {}
func (userWithPrismaPostEqualsUniqueParam) equals() {}

type UserWithPrismaCommentsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	commentsField()
}

type UserWithPrismaCommentsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	commentsField()
}

type userWithPrismaCommentsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsSetParam) userModel() {}

func (p userWithPrismaCommentsSetParam) commentsField() {}

type UserWithPrismaCommentsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	commentsField()
}

type userWithPrismaCommentsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsEqualsParam) userModel() {}

func (p userWithPrismaCommentsEqualsParam) commentsField() {}

func (userWithPrismaCommentsSetParam) settable()  {}
func (userWithPrismaCommentsEqualsParam) equals() {}

type userWithPrismaCommentsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsEqualsUniqueParam) userModel()     {}
func (p userWithPrismaCommentsEqualsUniqueParam) commentsField() {}

func (userWithPrismaCommentsEqualsUniqueParam) unique() {}
func (userWithPrismaCommentsEqualsUniqueParam) equals() {}

type postActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var postOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "content"},
	{Name: "title"},
	{Name: "authorID"},
}

type PostRelationWith interface {
	getQuery() builder.Query
	with()
	postRelation()
}

type PostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p postDefaultParam) field() builder.Field {
	return p.data
}

func (p postDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p postDefaultParam) postModel() {}

type PostOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p postOrderByParam) field() builder.Field {
	return p.data
}

func (p postOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p postOrderByParam) postModel() {}

type PostCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	isCursor()
}

type postCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p postCursorParam) field() builder.Field {
	return p.data
}

func (p postCursorParam) isCursor() {}

func (p postCursorParam) getQuery() builder.Query {
	return p.query
}

func (p postCursorParam) postModel() {}

type PostParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	postModel()
}

type postParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p postParamUnique) postModel() {}

func (postParamUnique) unique() {}

func (p postParamUnique) field() builder.Field {
	return p.data
}

func (p postParamUnique) getQuery() builder.Query {
	return p.query
}

type PostEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
}

type postEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postEqualsParam) postModel() {}

func (postEqualsParam) equals() {}

func (p postEqualsParam) field() builder.Field {
	return p.data
}

func (p postEqualsParam) getQuery() builder.Query {
	return p.query
}

type PostEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	postModel()
}

type postEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postEqualsUniqueParam) postModel() {}

func (postEqualsUniqueParam) unique() {}
func (postEqualsUniqueParam) equals() {}

func (p postEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type PostSetParam interface {
	field() builder.Field
	settable()
	postModel()
}

type postSetParam struct {
	data builder.Field
}

func (postSetParam) settable() {}

func (p postSetParam) field() builder.Field {
	return p.data
}

func (p postSetParam) postModel() {}

type PostWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	idField()
}

type PostWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	idField()
}

type postWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDSetParam) postModel() {}

func (p postWithPrismaIDSetParam) idField() {}

type PostWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	idField()
}

type postWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDEqualsParam) postModel() {}

func (p postWithPrismaIDEqualsParam) idField() {}

func (postWithPrismaIDSetParam) settable()  {}
func (postWithPrismaIDEqualsParam) equals() {}

type postWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDEqualsUniqueParam) postModel() {}
func (p postWithPrismaIDEqualsUniqueParam) idField()   {}

func (postWithPrismaIDEqualsUniqueParam) unique() {}
func (postWithPrismaIDEqualsUniqueParam) equals() {}

type PostWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	createdAtField()
}

type PostWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	createdAtField()
}

type postWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtSetParam) postModel() {}

func (p postWithPrismaCreatedAtSetParam) createdAtField() {}

type PostWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	createdAtField()
}

type postWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtEqualsParam) postModel() {}

func (p postWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (postWithPrismaCreatedAtSetParam) settable()  {}
func (postWithPrismaCreatedAtEqualsParam) equals() {}

type postWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) postModel()      {}
func (p postWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (postWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (postWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type PostWithPrismaContentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	contentField()
}

type PostWithPrismaContentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	contentField()
}

type postWithPrismaContentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaContentSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaContentSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaContentSetParam) postModel() {}

func (p postWithPrismaContentSetParam) contentField() {}

type PostWithPrismaContentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	contentField()
}

type postWithPrismaContentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaContentEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaContentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaContentEqualsParam) postModel() {}

func (p postWithPrismaContentEqualsParam) contentField() {}

func (postWithPrismaContentSetParam) settable()  {}
func (postWithPrismaContentEqualsParam) equals() {}

type postWithPrismaContentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaContentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaContentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaContentEqualsUniqueParam) postModel()    {}
func (p postWithPrismaContentEqualsUniqueParam) contentField() {}

func (postWithPrismaContentEqualsUniqueParam) unique() {}
func (postWithPrismaContentEqualsUniqueParam) equals() {}

type PostWithPrismaTitleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	titleField()
}

type PostWithPrismaTitleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	titleField()
}

type postWithPrismaTitleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTitleSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTitleSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTitleSetParam) postModel() {}

func (p postWithPrismaTitleSetParam) titleField() {}

type PostWithPrismaTitleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	titleField()
}

type postWithPrismaTitleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTitleEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTitleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTitleEqualsParam) postModel() {}

func (p postWithPrismaTitleEqualsParam) titleField() {}

func (postWithPrismaTitleSetParam) settable()  {}
func (postWithPrismaTitleEqualsParam) equals() {}

type postWithPrismaTitleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTitleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTitleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTitleEqualsUniqueParam) postModel()  {}
func (p postWithPrismaTitleEqualsUniqueParam) titleField() {}

func (postWithPrismaTitleEqualsUniqueParam) unique() {}
func (postWithPrismaTitleEqualsUniqueParam) equals() {}

type PostWithPrismaAuthorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	authorField()
}

type PostWithPrismaAuthorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	authorField()
}

type postWithPrismaAuthorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaAuthorSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaAuthorSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaAuthorSetParam) postModel() {}

func (p postWithPrismaAuthorSetParam) authorField() {}

type PostWithPrismaAuthorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	authorField()
}

type postWithPrismaAuthorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaAuthorEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaAuthorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaAuthorEqualsParam) postModel() {}

func (p postWithPrismaAuthorEqualsParam) authorField() {}

func (postWithPrismaAuthorSetParam) settable()  {}
func (postWithPrismaAuthorEqualsParam) equals() {}

type postWithPrismaAuthorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaAuthorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaAuthorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaAuthorEqualsUniqueParam) postModel()   {}
func (p postWithPrismaAuthorEqualsUniqueParam) authorField() {}

func (postWithPrismaAuthorEqualsUniqueParam) unique() {}
func (postWithPrismaAuthorEqualsUniqueParam) equals() {}

type PostWithPrismaAuthorIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	authorIDField()
}

type PostWithPrismaAuthorIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	authorIDField()
}

type postWithPrismaAuthorIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaAuthorIDSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaAuthorIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaAuthorIDSetParam) postModel() {}

func (p postWithPrismaAuthorIDSetParam) authorIDField() {}

type PostWithPrismaAuthorIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	authorIDField()
}

type postWithPrismaAuthorIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaAuthorIDEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaAuthorIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaAuthorIDEqualsParam) postModel() {}

func (p postWithPrismaAuthorIDEqualsParam) authorIDField() {}

func (postWithPrismaAuthorIDSetParam) settable()  {}
func (postWithPrismaAuthorIDEqualsParam) equals() {}

type postWithPrismaAuthorIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaAuthorIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaAuthorIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaAuthorIDEqualsUniqueParam) postModel()     {}
func (p postWithPrismaAuthorIDEqualsUniqueParam) authorIDField() {}

func (postWithPrismaAuthorIDEqualsUniqueParam) unique() {}
func (postWithPrismaAuthorIDEqualsUniqueParam) equals() {}

type PostWithPrismaCommentsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	commentsField()
}

type PostWithPrismaCommentsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	commentsField()
}

type postWithPrismaCommentsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCommentsSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCommentsSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCommentsSetParam) postModel() {}

func (p postWithPrismaCommentsSetParam) commentsField() {}

type PostWithPrismaCommentsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	commentsField()
}

type postWithPrismaCommentsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCommentsEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCommentsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCommentsEqualsParam) postModel() {}

func (p postWithPrismaCommentsEqualsParam) commentsField() {}

func (postWithPrismaCommentsSetParam) settable()  {}
func (postWithPrismaCommentsEqualsParam) equals() {}

type postWithPrismaCommentsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCommentsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCommentsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCommentsEqualsUniqueParam) postModel()     {}
func (p postWithPrismaCommentsEqualsUniqueParam) commentsField() {}

func (postWithPrismaCommentsEqualsUniqueParam) unique() {}
func (postWithPrismaCommentsEqualsUniqueParam) equals() {}

type commentActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var commentOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "content"},
	{Name: "postID"},
	{Name: "userID"},
}

type CommentRelationWith interface {
	getQuery() builder.Query
	with()
	commentRelation()
}

type CommentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
}

type commentDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentDefaultParam) field() builder.Field {
	return p.data
}

func (p commentDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p commentDefaultParam) commentModel() {}

type CommentOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
}

type commentOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentOrderByParam) field() builder.Field {
	return p.data
}

func (p commentOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p commentOrderByParam) commentModel() {}

type CommentCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	isCursor()
}

type commentCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentCursorParam) field() builder.Field {
	return p.data
}

func (p commentCursorParam) isCursor() {}

func (p commentCursorParam) getQuery() builder.Query {
	return p.query
}

func (p commentCursorParam) commentModel() {}

type CommentParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	commentModel()
}

type commentParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p commentParamUnique) commentModel() {}

func (commentParamUnique) unique() {}

func (p commentParamUnique) field() builder.Field {
	return p.data
}

func (p commentParamUnique) getQuery() builder.Query {
	return p.query
}

type CommentEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
}

type commentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentEqualsParam) commentModel() {}

func (commentEqualsParam) equals() {}

func (p commentEqualsParam) field() builder.Field {
	return p.data
}

func (p commentEqualsParam) getQuery() builder.Query {
	return p.query
}

type CommentEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	commentModel()
}

type commentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentEqualsUniqueParam) commentModel() {}

func (commentEqualsUniqueParam) unique() {}
func (commentEqualsUniqueParam) equals() {}

func (p commentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type CommentSetParam interface {
	field() builder.Field
	settable()
	commentModel()
}

type commentSetParam struct {
	data builder.Field
}

func (commentSetParam) settable() {}

func (p commentSetParam) field() builder.Field {
	return p.data
}

func (p commentSetParam) commentModel() {}

type CommentWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	idField()
}

type CommentWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	idField()
}

type commentWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaIDSetParam) commentModel() {}

func (p commentWithPrismaIDSetParam) idField() {}

type CommentWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	idField()
}

type commentWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaIDEqualsParam) commentModel() {}

func (p commentWithPrismaIDEqualsParam) idField() {}

func (commentWithPrismaIDSetParam) settable()  {}
func (commentWithPrismaIDEqualsParam) equals() {}

type commentWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaIDEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaIDEqualsUniqueParam) idField()      {}

func (commentWithPrismaIDEqualsUniqueParam) unique() {}
func (commentWithPrismaIDEqualsUniqueParam) equals() {}

type CommentWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	createdAtField()
}

type CommentWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	createdAtField()
}

type commentWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaCreatedAtSetParam) commentModel() {}

func (p commentWithPrismaCreatedAtSetParam) createdAtField() {}

type CommentWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	createdAtField()
}

type commentWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaCreatedAtEqualsParam) commentModel() {}

func (p commentWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (commentWithPrismaCreatedAtSetParam) settable()  {}
func (commentWithPrismaCreatedAtEqualsParam) equals() {}

type commentWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaCreatedAtEqualsUniqueParam) commentModel()   {}
func (p commentWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (commentWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (commentWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type CommentWithPrismaContentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	contentField()
}

type CommentWithPrismaContentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	contentField()
}

type commentWithPrismaContentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaContentSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaContentSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaContentSetParam) commentModel() {}

func (p commentWithPrismaContentSetParam) contentField() {}

type CommentWithPrismaContentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	contentField()
}

type commentWithPrismaContentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaContentEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaContentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaContentEqualsParam) commentModel() {}

func (p commentWithPrismaContentEqualsParam) contentField() {}

func (commentWithPrismaContentSetParam) settable()  {}
func (commentWithPrismaContentEqualsParam) equals() {}

type commentWithPrismaContentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaContentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaContentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaContentEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaContentEqualsUniqueParam) contentField() {}

func (commentWithPrismaContentEqualsUniqueParam) unique() {}
func (commentWithPrismaContentEqualsUniqueParam) equals() {}

type CommentWithPrismaPostEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	postField()
}

type CommentWithPrismaPostSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postField()
}

type commentWithPrismaPostSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostSetParam) commentModel() {}

func (p commentWithPrismaPostSetParam) postField() {}

type CommentWithPrismaPostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postField()
}

type commentWithPrismaPostEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostEqualsParam) commentModel() {}

func (p commentWithPrismaPostEqualsParam) postField() {}

func (commentWithPrismaPostSetParam) settable()  {}
func (commentWithPrismaPostEqualsParam) equals() {}

type commentWithPrismaPostEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaPostEqualsUniqueParam) postField()    {}

func (commentWithPrismaPostEqualsUniqueParam) unique() {}
func (commentWithPrismaPostEqualsUniqueParam) equals() {}

type CommentWithPrismaPostIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	postIDField()
}

type CommentWithPrismaPostIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postIDField()
}

type commentWithPrismaPostIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostIDSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostIDSetParam) commentModel() {}

func (p commentWithPrismaPostIDSetParam) postIDField() {}

type CommentWithPrismaPostIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postIDField()
}

type commentWithPrismaPostIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostIDEqualsParam) commentModel() {}

func (p commentWithPrismaPostIDEqualsParam) postIDField() {}

func (commentWithPrismaPostIDSetParam) settable()  {}
func (commentWithPrismaPostIDEqualsParam) equals() {}

type commentWithPrismaPostIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostIDEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaPostIDEqualsUniqueParam) postIDField()  {}

func (commentWithPrismaPostIDEqualsUniqueParam) unique() {}
func (commentWithPrismaPostIDEqualsUniqueParam) equals() {}

type CommentWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	userField()
}

type CommentWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userField()
}

type commentWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserSetParam) commentModel() {}

func (p commentWithPrismaUserSetParam) userField() {}

type CommentWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userField()
}

type commentWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserEqualsParam) commentModel() {}

func (p commentWithPrismaUserEqualsParam) userField() {}

func (commentWithPrismaUserSetParam) settable()  {}
func (commentWithPrismaUserEqualsParam) equals() {}

type commentWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaUserEqualsUniqueParam) userField()    {}

func (commentWithPrismaUserEqualsUniqueParam) unique() {}
func (commentWithPrismaUserEqualsUniqueParam) equals() {}

type CommentWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	userIDField()
}

type CommentWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userIDField()
}

type commentWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserIDSetParam) commentModel() {}

func (p commentWithPrismaUserIDSetParam) userIDField() {}

type CommentWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userIDField()
}

type commentWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserIDEqualsParam) commentModel() {}

func (p commentWithPrismaUserIDEqualsParam) userIDField() {}

func (commentWithPrismaUserIDSetParam) settable()  {}
func (commentWithPrismaUserIDEqualsParam) equals() {}

type commentWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserIDEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaUserIDEqualsUniqueParam) userIDField()  {}

func (commentWithPrismaUserIDEqualsUniqueParam) unique() {}
func (commentWithPrismaUserIDEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_name UserWithPrismaNameSetParam,
	_password UserWithPrismaPasswordSetParam,
	_email UserWithPrismaEmailSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _password.field())
	fields = append(fields, _email.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single post.
func (r postActions) CreateOne(
	_content PostWithPrismaContentSetParam,
	_title PostWithPrismaTitleSetParam,
	_author PostWithPrismaAuthorSetParam,

	optional ...PostSetParam,
) postCreateOne {
	var v postCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var fields []builder.Field

	fields = append(fields, _content.field())
	fields = append(fields, _title.field())
	fields = append(fields, _author.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r postCreateOne) With(params ...PostRelationWith) postCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type postCreateOne struct {
	query builder.Query
}

func (p postCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p postCreateOne) postModel() {}

func (r postCreateOne) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postCreateOne) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single comment.
func (r commentActions) CreateOne(
	_content CommentWithPrismaContentSetParam,
	_post CommentWithPrismaPostSetParam,
	_user CommentWithPrismaUserSetParam,

	optional ...CommentSetParam,
) commentCreateOne {
	var v commentCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	var fields []builder.Field

	fields = append(fields, _content.field())
	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r commentCreateOne) With(params ...CommentRelationWith) commentCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type commentCreateOne struct {
	query builder.Query
}

func (p commentCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p commentCreateOne) commentModel() {}

func (r commentCreateOne) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentCreateOne) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userToPostFindUnique struct {
	query builder.Query
}

func (r userToPostFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToPostFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostFindUnique) with()         {}
func (r userToPostFindUnique) userModel()    {}
func (r userToPostFindUnique) userRelation() {}

func (r userToPostFindUnique) With(params ...PostRelationWith) userToPostFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostFindUnique) Select(params ...userPrismaFields) userToPostFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostFindUnique) Omit(params ...userPrismaFields) userToPostFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPostFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPostFindUnique) Update(params ...UserSetParam) userToPostUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToPostUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPostUpdateUnique struct {
	query builder.Query
}

func (r userToPostUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostUpdateUnique) userModel() {}

func (r userToPostUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToPostFindUnique) Delete() userToPostDeleteUnique {
	var v userToPostDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToPostDeleteUnique struct {
	query builder.Query
}

func (r userToPostDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToPostDeleteUnique) userModel() {}

func (r userToPostDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToPostFindFirst struct {
	query builder.Query
}

func (r userToPostFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToPostFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostFindFirst) with()         {}
func (r userToPostFindFirst) userModel()    {}
func (r userToPostFindFirst) userRelation() {}

func (r userToPostFindFirst) With(params ...PostRelationWith) userToPostFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostFindFirst) Select(params ...userPrismaFields) userToPostFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostFindFirst) Omit(params ...userPrismaFields) userToPostFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostFindFirst) OrderBy(params ...PostOrderByParam) userToPostFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToPostFindFirst) Skip(count int) userToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToPostFindFirst) Take(count int) userToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToPostFindFirst) Cursor(cursor UserCursorParam) userToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPostFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPostFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToPostFindMany struct {
	query builder.Query
}

func (r userToPostFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToPostFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostFindMany) with()         {}
func (r userToPostFindMany) userModel()    {}
func (r userToPostFindMany) userRelation() {}

func (r userToPostFindMany) With(params ...PostRelationWith) userToPostFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostFindMany) Select(params ...userPrismaFields) userToPostFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostFindMany) Omit(params ...userPrismaFields) userToPostFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostFindMany) OrderBy(params ...PostOrderByParam) userToPostFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToPostFindMany) Skip(count int) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToPostFindMany) Take(count int) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToPostFindMany) Cursor(cursor UserCursorParam) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPostFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToPostFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToPostFindMany) Update(params ...UserSetParam) userToPostUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToPostUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPostUpdateMany struct {
	query builder.Query
}

func (r userToPostUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostUpdateMany) userModel() {}

func (r userToPostUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToPostFindMany) Delete() userToPostDeleteMany {
	var v userToPostDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToPostDeleteMany struct {
	query builder.Query
}

func (r userToPostDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToPostDeleteMany) userModel() {}

func (r userToPostDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToCommentsFindUnique struct {
	query builder.Query
}

func (r userToCommentsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindUnique) with()         {}
func (r userToCommentsFindUnique) userModel()    {}
func (r userToCommentsFindUnique) userRelation() {}

func (r userToCommentsFindUnique) With(params ...CommentRelationWith) userToCommentsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindUnique) Select(params ...userPrismaFields) userToCommentsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindUnique) Omit(params ...userPrismaFields) userToCommentsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindUnique) Update(params ...UserSetParam) userToCommentsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToCommentsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToCommentsUpdateUnique struct {
	query builder.Query
}

func (r userToCommentsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsUpdateUnique) userModel() {}

func (r userToCommentsUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToCommentsFindUnique) Delete() userToCommentsDeleteUnique {
	var v userToCommentsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToCommentsDeleteUnique struct {
	query builder.Query
}

func (r userToCommentsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToCommentsDeleteUnique) userModel() {}

func (r userToCommentsDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToCommentsFindFirst struct {
	query builder.Query
}

func (r userToCommentsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindFirst) with()         {}
func (r userToCommentsFindFirst) userModel()    {}
func (r userToCommentsFindFirst) userRelation() {}

func (r userToCommentsFindFirst) With(params ...CommentRelationWith) userToCommentsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindFirst) Select(params ...userPrismaFields) userToCommentsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindFirst) Omit(params ...userPrismaFields) userToCommentsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindFirst) OrderBy(params ...CommentOrderByParam) userToCommentsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToCommentsFindFirst) Skip(count int) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToCommentsFindFirst) Take(count int) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToCommentsFindFirst) Cursor(cursor UserCursorParam) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToCommentsFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToCommentsFindMany struct {
	query builder.Query
}

func (r userToCommentsFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindMany) with()         {}
func (r userToCommentsFindMany) userModel()    {}
func (r userToCommentsFindMany) userRelation() {}

func (r userToCommentsFindMany) With(params ...CommentRelationWith) userToCommentsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindMany) Select(params ...userPrismaFields) userToCommentsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindMany) Omit(params ...userPrismaFields) userToCommentsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindMany) OrderBy(params ...CommentOrderByParam) userToCommentsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToCommentsFindMany) Skip(count int) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToCommentsFindMany) Take(count int) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToCommentsFindMany) Cursor(cursor UserCursorParam) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToCommentsFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToCommentsFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToCommentsFindMany) Update(params ...UserSetParam) userToCommentsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToCommentsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToCommentsUpdateMany struct {
	query builder.Query
}

func (r userToCommentsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsUpdateMany) userModel() {}

func (r userToCommentsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToCommentsFindMany) Delete() userToCommentsDeleteMany {
	var v userToCommentsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToCommentsDeleteMany struct {
	query builder.Query
}

func (r userToCommentsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToCommentsDeleteMany) userModel() {}

func (r userToCommentsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Select(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Omit(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) Select(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) Omit(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) Select(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) Omit(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToAuthorFindUnique struct {
	query builder.Query
}

func (r postToAuthorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToAuthorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToAuthorFindUnique) with()         {}
func (r postToAuthorFindUnique) postModel()    {}
func (r postToAuthorFindUnique) postRelation() {}

func (r postToAuthorFindUnique) With(params ...UserRelationWith) postToAuthorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToAuthorFindUnique) Select(params ...postPrismaFields) postToAuthorFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToAuthorFindUnique) Omit(params ...postPrismaFields) postToAuthorFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToAuthorFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToAuthorFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToAuthorFindUnique) Update(params ...PostSetParam) postToAuthorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToAuthorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToAuthorUpdateUnique struct {
	query builder.Query
}

func (r postToAuthorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToAuthorUpdateUnique) postModel() {}

func (r postToAuthorUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToAuthorUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToAuthorFindUnique) Delete() postToAuthorDeleteUnique {
	var v postToAuthorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToAuthorDeleteUnique struct {
	query builder.Query
}

func (r postToAuthorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToAuthorDeleteUnique) postModel() {}

func (r postToAuthorDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToAuthorDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToAuthorFindFirst struct {
	query builder.Query
}

func (r postToAuthorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToAuthorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToAuthorFindFirst) with()         {}
func (r postToAuthorFindFirst) postModel()    {}
func (r postToAuthorFindFirst) postRelation() {}

func (r postToAuthorFindFirst) With(params ...UserRelationWith) postToAuthorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToAuthorFindFirst) Select(params ...postPrismaFields) postToAuthorFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToAuthorFindFirst) Omit(params ...postPrismaFields) postToAuthorFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToAuthorFindFirst) OrderBy(params ...UserOrderByParam) postToAuthorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToAuthorFindFirst) Skip(count int) postToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToAuthorFindFirst) Take(count int) postToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToAuthorFindFirst) Cursor(cursor PostCursorParam) postToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToAuthorFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToAuthorFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToAuthorFindMany struct {
	query builder.Query
}

func (r postToAuthorFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToAuthorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToAuthorFindMany) with()         {}
func (r postToAuthorFindMany) postModel()    {}
func (r postToAuthorFindMany) postRelation() {}

func (r postToAuthorFindMany) With(params ...UserRelationWith) postToAuthorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToAuthorFindMany) Select(params ...postPrismaFields) postToAuthorFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToAuthorFindMany) Omit(params ...postPrismaFields) postToAuthorFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToAuthorFindMany) OrderBy(params ...UserOrderByParam) postToAuthorFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToAuthorFindMany) Skip(count int) postToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToAuthorFindMany) Take(count int) postToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToAuthorFindMany) Cursor(cursor PostCursorParam) postToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToAuthorFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToAuthorFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToAuthorFindMany) Update(params ...PostSetParam) postToAuthorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToAuthorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToAuthorUpdateMany struct {
	query builder.Query
}

func (r postToAuthorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToAuthorUpdateMany) postModel() {}

func (r postToAuthorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToAuthorUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToAuthorFindMany) Delete() postToAuthorDeleteMany {
	var v postToAuthorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToAuthorDeleteMany struct {
	query builder.Query
}

func (r postToAuthorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToAuthorDeleteMany) postModel() {}

func (r postToAuthorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToAuthorDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToCommentsFindUnique struct {
	query builder.Query
}

func (r postToCommentsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindUnique) with()         {}
func (r postToCommentsFindUnique) postModel()    {}
func (r postToCommentsFindUnique) postRelation() {}

func (r postToCommentsFindUnique) With(params ...CommentRelationWith) postToCommentsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToCommentsFindUnique) Select(params ...postPrismaFields) postToCommentsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindUnique) Omit(params ...postPrismaFields) postToCommentsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToCommentsFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToCommentsFindUnique) Update(params ...PostSetParam) postToCommentsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToCommentsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToCommentsUpdateUnique struct {
	query builder.Query
}

func (r postToCommentsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsUpdateUnique) postModel() {}

func (r postToCommentsUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToCommentsFindUnique) Delete() postToCommentsDeleteUnique {
	var v postToCommentsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToCommentsDeleteUnique struct {
	query builder.Query
}

func (r postToCommentsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToCommentsDeleteUnique) postModel() {}

func (r postToCommentsDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToCommentsFindFirst struct {
	query builder.Query
}

func (r postToCommentsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindFirst) with()         {}
func (r postToCommentsFindFirst) postModel()    {}
func (r postToCommentsFindFirst) postRelation() {}

func (r postToCommentsFindFirst) With(params ...CommentRelationWith) postToCommentsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToCommentsFindFirst) Select(params ...postPrismaFields) postToCommentsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindFirst) Omit(params ...postPrismaFields) postToCommentsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindFirst) OrderBy(params ...CommentOrderByParam) postToCommentsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToCommentsFindFirst) Skip(count int) postToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToCommentsFindFirst) Take(count int) postToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToCommentsFindFirst) Cursor(cursor PostCursorParam) postToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToCommentsFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToCommentsFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToCommentsFindMany struct {
	query builder.Query
}

func (r postToCommentsFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindMany) with()         {}
func (r postToCommentsFindMany) postModel()    {}
func (r postToCommentsFindMany) postRelation() {}

func (r postToCommentsFindMany) With(params ...CommentRelationWith) postToCommentsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToCommentsFindMany) Select(params ...postPrismaFields) postToCommentsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindMany) Omit(params ...postPrismaFields) postToCommentsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindMany) OrderBy(params ...CommentOrderByParam) postToCommentsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToCommentsFindMany) Skip(count int) postToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToCommentsFindMany) Take(count int) postToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToCommentsFindMany) Cursor(cursor PostCursorParam) postToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToCommentsFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToCommentsFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToCommentsFindMany) Update(params ...PostSetParam) postToCommentsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToCommentsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToCommentsUpdateMany struct {
	query builder.Query
}

func (r postToCommentsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsUpdateMany) postModel() {}

func (r postToCommentsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToCommentsFindMany) Delete() postToCommentsDeleteMany {
	var v postToCommentsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToCommentsDeleteMany struct {
	query builder.Query
}

func (r postToCommentsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToCommentsDeleteMany) postModel() {}

func (r postToCommentsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postFindUnique struct {
	query builder.Query
}

func (r postFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindUnique) with()         {}
func (r postFindUnique) postModel()    {}
func (r postFindUnique) postRelation() {}

func (r postActions) FindUnique(
	params PostEqualsUniqueWhereParam,
) postFindUnique {
	var v postFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r postFindUnique) With(params ...PostRelationWith) postFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindUnique) Select(params ...postPrismaFields) postFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindUnique) Omit(params ...postPrismaFields) postFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindUnique) Update(params ...PostSetParam) postUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateUnique struct {
	query builder.Query
}

func (r postUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpdateUnique) postModel() {}

func (r postUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postFindUnique) Delete() postDeleteUnique {
	var v postDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postDeleteUnique struct {
	query builder.Query
}

func (r postDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postDeleteUnique) postModel() {}

func (r postDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postFindFirst struct {
	query builder.Query
}

func (r postFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindFirst) with()         {}
func (r postFindFirst) postModel()    {}
func (r postFindFirst) postRelation() {}

func (r postActions) FindFirst(
	params ...PostWhereParam,
) postFindFirst {
	var v postFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postFindFirst) With(params ...PostRelationWith) postFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindFirst) Select(params ...postPrismaFields) postFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindFirst) Omit(params ...postPrismaFields) postFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindFirst) OrderBy(params ...PostOrderByParam) postFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postFindFirst) Skip(count int) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postFindFirst) Take(count int) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postFindFirst) Cursor(cursor PostCursorParam) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postFindMany struct {
	query builder.Query
}

func (r postFindMany) getQuery() builder.Query {
	return r.query
}

func (r postFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindMany) with()         {}
func (r postFindMany) postModel()    {}
func (r postFindMany) postRelation() {}

func (r postActions) FindMany(
	params ...PostWhereParam,
) postFindMany {
	var v postFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postFindMany) With(params ...PostRelationWith) postFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindMany) Select(params ...postPrismaFields) postFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindMany) Omit(params ...postPrismaFields) postFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindMany) OrderBy(params ...PostOrderByParam) postFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postFindMany) Skip(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postFindMany) Take(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postFindMany) Cursor(cursor PostCursorParam) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postFindMany) Update(params ...PostSetParam) postUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateMany struct {
	query builder.Query
}

func (r postUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpdateMany) postModel() {}

func (r postUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postFindMany) Delete() postDeleteMany {
	var v postDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postDeleteMany struct {
	query builder.Query
}

func (r postDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postDeleteMany) postModel() {}

func (r postDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToPostFindUnique struct {
	query builder.Query
}

func (r commentToPostFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentToPostFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostFindUnique) with()            {}
func (r commentToPostFindUnique) commentModel()    {}
func (r commentToPostFindUnique) commentRelation() {}

func (r commentToPostFindUnique) With(params ...PostRelationWith) commentToPostFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToPostFindUnique) Select(params ...commentPrismaFields) commentToPostFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindUnique) Omit(params ...commentPrismaFields) commentToPostFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindUnique) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToPostFindUnique) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToPostFindUnique) Update(params ...CommentSetParam) commentToPostUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comment"

	var v commentToPostUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToPostUpdateUnique struct {
	query builder.Query
}

func (r commentToPostUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostUpdateUnique) commentModel() {}

func (r commentToPostUpdateUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostUpdateUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToPostFindUnique) Delete() commentToPostDeleteUnique {
	var v commentToPostDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comment"

	return v
}

type commentToPostDeleteUnique struct {
	query builder.Query
}

func (r commentToPostDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToPostDeleteUnique) commentModel() {}

func (r commentToPostDeleteUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostDeleteUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToPostFindFirst struct {
	query builder.Query
}

func (r commentToPostFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentToPostFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostFindFirst) with()            {}
func (r commentToPostFindFirst) commentModel()    {}
func (r commentToPostFindFirst) commentRelation() {}

func (r commentToPostFindFirst) With(params ...PostRelationWith) commentToPostFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToPostFindFirst) Select(params ...commentPrismaFields) commentToPostFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindFirst) Omit(params ...commentPrismaFields) commentToPostFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindFirst) OrderBy(params ...PostOrderByParam) commentToPostFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToPostFindFirst) Skip(count int) commentToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToPostFindFirst) Take(count int) commentToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToPostFindFirst) Cursor(cursor CommentCursorParam) commentToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToPostFindFirst) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToPostFindFirst) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentToPostFindMany struct {
	query builder.Query
}

func (r commentToPostFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentToPostFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostFindMany) with()            {}
func (r commentToPostFindMany) commentModel()    {}
func (r commentToPostFindMany) commentRelation() {}

func (r commentToPostFindMany) With(params ...PostRelationWith) commentToPostFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToPostFindMany) Select(params ...commentPrismaFields) commentToPostFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindMany) Omit(params ...commentPrismaFields) commentToPostFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindMany) OrderBy(params ...PostOrderByParam) commentToPostFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToPostFindMany) Skip(count int) commentToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToPostFindMany) Take(count int) commentToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToPostFindMany) Cursor(cursor CommentCursorParam) commentToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToPostFindMany) Exec(ctx context.Context) (
	[]CommentModel,
	error,
) {
	var v []CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToPostFindMany) ExecInner(ctx context.Context) (
	[]InnerComment,
	error,
) {
	var v []InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToPostFindMany) Update(params ...CommentSetParam) commentToPostUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comment"

	r.query.Outputs = countOutput

	var v commentToPostUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToPostUpdateMany struct {
	query builder.Query
}

func (r commentToPostUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostUpdateMany) commentModel() {}

func (r commentToPostUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostUpdateMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToPostFindMany) Delete() commentToPostDeleteMany {
	var v commentToPostDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comment"

	v.query.Outputs = countOutput

	return v
}

type commentToPostDeleteMany struct {
	query builder.Query
}

func (r commentToPostDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToPostDeleteMany) commentModel() {}

func (r commentToPostDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostDeleteMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToUserFindUnique struct {
	query builder.Query
}

func (r commentToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserFindUnique) with()            {}
func (r commentToUserFindUnique) commentModel()    {}
func (r commentToUserFindUnique) commentRelation() {}

func (r commentToUserFindUnique) With(params ...UserRelationWith) commentToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToUserFindUnique) Select(params ...commentPrismaFields) commentToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindUnique) Omit(params ...commentPrismaFields) commentToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindUnique) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToUserFindUnique) Update(params ...CommentSetParam) commentToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comment"

	var v commentToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToUserUpdateUnique struct {
	query builder.Query
}

func (r commentToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserUpdateUnique) commentModel() {}

func (r commentToUserUpdateUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserUpdateUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToUserFindUnique) Delete() commentToUserDeleteUnique {
	var v commentToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comment"

	return v
}

type commentToUserDeleteUnique struct {
	query builder.Query
}

func (r commentToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToUserDeleteUnique) commentModel() {}

func (r commentToUserDeleteUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserDeleteUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToUserFindFirst struct {
	query builder.Query
}

func (r commentToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserFindFirst) with()            {}
func (r commentToUserFindFirst) commentModel()    {}
func (r commentToUserFindFirst) commentRelation() {}

func (r commentToUserFindFirst) With(params ...UserRelationWith) commentToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToUserFindFirst) Select(params ...commentPrismaFields) commentToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindFirst) Omit(params ...commentPrismaFields) commentToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindFirst) OrderBy(params ...UserOrderByParam) commentToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToUserFindFirst) Skip(count int) commentToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToUserFindFirst) Take(count int) commentToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToUserFindFirst) Cursor(cursor CommentCursorParam) commentToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToUserFindFirst) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentToUserFindMany struct {
	query builder.Query
}

func (r commentToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserFindMany) with()            {}
func (r commentToUserFindMany) commentModel()    {}
func (r commentToUserFindMany) commentRelation() {}

func (r commentToUserFindMany) With(params ...UserRelationWith) commentToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToUserFindMany) Select(params ...commentPrismaFields) commentToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindMany) Omit(params ...commentPrismaFields) commentToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindMany) OrderBy(params ...UserOrderByParam) commentToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToUserFindMany) Skip(count int) commentToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToUserFindMany) Take(count int) commentToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToUserFindMany) Cursor(cursor CommentCursorParam) commentToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToUserFindMany) Exec(ctx context.Context) (
	[]CommentModel,
	error,
) {
	var v []CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerComment,
	error,
) {
	var v []InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToUserFindMany) Update(params ...CommentSetParam) commentToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comment"

	r.query.Outputs = countOutput

	var v commentToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToUserUpdateMany struct {
	query builder.Query
}

func (r commentToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserUpdateMany) commentModel() {}

func (r commentToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserUpdateMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToUserFindMany) Delete() commentToUserDeleteMany {
	var v commentToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comment"

	v.query.Outputs = countOutput

	return v
}

type commentToUserDeleteMany struct {
	query builder.Query
}

func (r commentToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToUserDeleteMany) commentModel() {}

func (r commentToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserDeleteMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentFindUnique struct {
	query builder.Query
}

func (r commentFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentFindUnique) with()            {}
func (r commentFindUnique) commentModel()    {}
func (r commentFindUnique) commentRelation() {}

func (r commentActions) FindUnique(
	params CommentEqualsUniqueWhereParam,
) commentFindUnique {
	var v commentFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r commentFindUnique) With(params ...CommentRelationWith) commentFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentFindUnique) Select(params ...commentPrismaFields) commentFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindUnique) Omit(params ...commentPrismaFields) commentFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindUnique) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentFindUnique) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentFindUnique) Update(params ...CommentSetParam) commentUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comment"

	var v commentUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentUpdateUnique struct {
	query builder.Query
}

func (r commentUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentUpdateUnique) commentModel() {}

func (r commentUpdateUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentUpdateUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentFindUnique) Delete() commentDeleteUnique {
	var v commentDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comment"

	return v
}

type commentDeleteUnique struct {
	query builder.Query
}

func (r commentDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentDeleteUnique) commentModel() {}

func (r commentDeleteUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentDeleteUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentFindFirst struct {
	query builder.Query
}

func (r commentFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentFindFirst) with()            {}
func (r commentFindFirst) commentModel()    {}
func (r commentFindFirst) commentRelation() {}

func (r commentActions) FindFirst(
	params ...CommentWhereParam,
) commentFindFirst {
	var v commentFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r commentFindFirst) With(params ...CommentRelationWith) commentFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentFindFirst) Select(params ...commentPrismaFields) commentFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindFirst) Omit(params ...commentPrismaFields) commentFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindFirst) OrderBy(params ...CommentOrderByParam) commentFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentFindFirst) Skip(count int) commentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentFindFirst) Take(count int) commentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentFindFirst) Cursor(cursor CommentCursorParam) commentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentFindFirst) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentFindFirst) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentFindMany struct {
	query builder.Query
}

func (r commentFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentFindMany) with()            {}
func (r commentFindMany) commentModel()    {}
func (r commentFindMany) commentRelation() {}

func (r commentActions) FindMany(
	params ...CommentWhereParam,
) commentFindMany {
	var v commentFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r commentFindMany) With(params ...CommentRelationWith) commentFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentFindMany) Select(params ...commentPrismaFields) commentFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindMany) Omit(params ...commentPrismaFields) commentFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindMany) OrderBy(params ...CommentOrderByParam) commentFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentFindMany) Skip(count int) commentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentFindMany) Take(count int) commentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentFindMany) Cursor(cursor CommentCursorParam) commentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentFindMany) Exec(ctx context.Context) (
	[]CommentModel,
	error,
) {
	var v []CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentFindMany) ExecInner(ctx context.Context) (
	[]InnerComment,
	error,
) {
	var v []InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentFindMany) Update(params ...CommentSetParam) commentUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comment"

	r.query.Outputs = countOutput

	var v commentUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentUpdateMany struct {
	query builder.Query
}

func (r commentUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentUpdateMany) commentModel() {}

func (r commentUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentUpdateMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentFindMany) Delete() commentDeleteMany {
	var v commentDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comment"

	v.query.Outputs = countOutput

	return v
}

type commentDeleteMany struct {
	query builder.Query
}

func (r commentDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentDeleteMany) commentModel() {}

func (r commentDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentDeleteMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newUserUniqueTxResult() UserUniqueTxResult {
	return UserUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserUniqueTxResult) IsTx() {}

func (r UserUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserManyTxResult() UserManyTxResult {
	return UserManyTxResult{
		result: &transaction.Result{},
	}
}

type UserManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserManyTxResult) IsTx() {}

func (r UserManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newPostUniqueTxResult() PostUniqueTxResult {
	return PostUniqueTxResult{
		result: &transaction.Result{},
	}
}

type PostUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p PostUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p PostUniqueTxResult) IsTx() {}

func (r PostUniqueTxResult) Result() (v *PostModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newPostManyTxResult() PostManyTxResult {
	return PostManyTxResult{
		result: &transaction.Result{},
	}
}

type PostManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p PostManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p PostManyTxResult) IsTx() {}

func (r PostManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCommentUniqueTxResult() CommentUniqueTxResult {
	return CommentUniqueTxResult{
		result: &transaction.Result{},
	}
}

type CommentUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CommentUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CommentUniqueTxResult) IsTx() {}

func (r CommentUniqueTxResult) Result() (v *CommentModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCommentManyTxResult() CommentManyTxResult {
	return CommentManyTxResult{
		result: &transaction.Result{},
	}
}

type CommentManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CommentManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CommentManyTxResult) IsTx() {}

func (r CommentManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_name UserWithPrismaNameSetParam,
	_password UserWithPrismaPasswordSetParam,
	_email UserWithPrismaEmailSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _password.field())
	fields = append(fields, _email.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postUpsertOne struct {
	query builder.Query
}

func (r postUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r postUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpsertOne) with()         {}
func (r postUpsertOne) postModel()    {}
func (r postUpsertOne) postRelation() {}

func (r postActions) UpsertOne(
	params PostEqualsUniqueWhereParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r postUpsertOne) Create(

	_content PostWithPrismaContentSetParam,
	_title PostWithPrismaTitleSetParam,
	_author PostWithPrismaAuthorSetParam,

	optional ...PostSetParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _content.field())
	fields = append(fields, _title.field())
	fields = append(fields, _author.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r postUpsertOne) Update(
	params ...PostSetParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r postUpsertOne) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpsertOne) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentUpsertOne struct {
	query builder.Query
}

func (r commentUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r commentUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r commentUpsertOne) with()            {}
func (r commentUpsertOne) commentModel()    {}
func (r commentUpsertOne) commentRelation() {}

func (r commentActions) UpsertOne(
	params CommentEqualsUniqueWhereParam,
) commentUpsertOne {
	var v commentUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r commentUpsertOne) Create(

	_content CommentWithPrismaContentSetParam,
	_post CommentWithPrismaPostSetParam,
	_user CommentWithPrismaUserSetParam,

	optional ...CommentSetParam,
) commentUpsertOne {
	var v commentUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _content.field())
	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r commentUpsertOne) Update(
	params ...CommentSetParam,
) commentUpsertOne {
	var v commentUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r commentUpsertOne) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentUpsertOne) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}
